package com.iluwatar.strategy.com.cherish.strategy.com.cherish.payment;

/**
 * 支付工资的策略接口，公司有多找那个支付工资的算法
 *      比如：现金、银行卡、现金加股票等
 *      分析：在实现这个需求时候，不同的策略算法需要的数据是不一样的。这就导致在设计策略接口中的方法时，不太好确定参数个数。
 *          例如：现金支付不需要银行卡号，而银行转账需要银行账号。
 *      方案：就是把上下文当作参数传递给策略对象。
 *
 *      步骤：
 *          1）定义支付工资的策略接口，即支付工资的方法；
 *          2）定义好了策略接口，该考虑如何实现这多种支付策略了。
 *          3）支付上下文，需要知道具体使用哪一个支付策略，一般由客户端来确定具体使用哪一个具体的策略，然后上下文负责真正执行。
 *          4）最后，看看如何使用策略来支付工资，客户端创建哪个策略，最后就运行哪一个策略，各个策略之间可以动态切换。
 *
 *          新需求：要求能支付到银行卡，该怎样去扩展最简单？
 *              1）方式一，新增一种支付到银行卡的策略实现，然后通过继承来扩展支付上下文。
 *              2）方式二，通过策略的构造方法传入新算法需要的数据。
 *                  分析：缺点，跟其他策略实现的风格不一致，其他策略都是从上下文获取数据，而这个策略的数据一部分来自上下文，一部分来自自己（构造函数传入）
 * @author zengjia
 */
public interface PaymentStrategy {

    /**
     * 公司给某人真正支付工资
     * @param ctx 支付工资的上下文，里面包含算法需要的数据
     */
    public void pay(PaymentContext ctx);
}
